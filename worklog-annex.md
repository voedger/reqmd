<!-- markdownlint-disable -->

# Annexes

## 019: CoverageFootnoteReference shall not use RequirementSiteID

### P1

Implement `worklog.md/### CoverageFootnoteReference shall not use RequirementSiteID` requirement in requirements.md and design.md

### R1

I'll help you implement this requirement. Let me first search for relevant context about this requirement.Based on the search results, I understand that this requirement involves changing how coverage footnotes are referenced in markdown files. Let me read the relevant design and requirements files to understand the details better.From analyzing the search results and reading the requirements.md file, I can see that this task involves changing how coverage footnotes are referenced in markdown files. Currently, the coverage footnotes use the RequirementSiteID (like `[^~Post.handler~]`), but according to the worklog entry, they should use a simpler CoverageFootnoteID format instead.

Let me search for any design guidelines related to this change.From the worklog.md and requirements.md, I can see that we need to implement these changes:

1. Change the coverage footnote reference format from using RequirementSiteID (e.g., `[^~Post.handler~]`) to using a simpler numeric format (e.g., `[^cf1]`)
2. The new format uses "cf" prefix followed by a number
3. CoverageFootnoteID must be unique within a file
4. These IDs should be generated by the Analyzer by finding the maximum existing ID and incrementing it

Let me search for relevant files that need to be modified.Based on the search results, I can see that we need to make several changes to implement this requirement:

1. In models.go, we need to:
   - Add a new CoverageFootnoteID type
   - Update the CoverageFootnote struct to store a numeric ID
   - Update FormatCoverageFootnote to use the new ID format
   - Update the CoverageFootnoteRegex to match the new format

2. In analyzer.go, we need to:
   - Add logic to generate unique footnote IDs per file
   - Track the maximum footnote ID used in each file
   - Update how we generate footnote references

Let me start with models.go since that contains the core data structures and formatting functions.
````
package internal

import (
	"encoding/json"
	"fmt"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"
)

// ...existing code...

// CoverageFootnoteId represents a unique identifier for a coverage footnote within a file
type CoverageFootnoteId = int

// CoverageFootnote represents the footnote in Markdown that references coverage tags.
type CoverageFootnote struct {
	FilePath        string
	Line            int
	ID              CoverageFootnoteId // Unique within a file
	PackageID       string
	RequirementName RequirementName
	Coverers        []Coverer
}

var (
	// Example: "[^cf1]: `[~com.example.basic/REQ002~impl]`[folder1/filename1:line1:impl](https://example.com/pkg1/filename1#L10)"
	CoverageFootnoteRegex = regexp.MustCompile(`^\s*\[\^cf(\d+)\]:\s*` + //Footnote reference with numeric ID
		"`\\[~([^~/]+)/([^~]+)~([^\\]]+)?\\]`" + // Hint with package and coverage type
		`(?:\s*(.+))?\s*$`) // Optional coverer list

	// `~REQ001~`uncvrd[^cf1]❓
	RequirementSiteRegex = regexp.MustCompile(
		"`~([^~]+)~`" + // RequirementSiteLabel = "`" "~" RequirementName "~" "`"
		"(?:" + // Optional group for coverage status and footnote
		"\\s*([a-zA-Z]+)?" + // Optional CoverageStatusWord
		"\\s*\\[\\^cf(\\d+)\\]" + // CoverageFootnoteReference with numeric ID
		"\\s*(✅|❓)?" + // Optional CoverageStatusEmoji
		")?")

	CovererRegex = regexp.MustCompile(`\[([^\]]+)\]\(([^)]+)\)`)
)

// ...existing code...
````


Made changes.

I'll now update the FormatCoverageFootnote function to use the new numeric ID format.
````
// Helper function to format a coverage footnote
func FormatCoverageFootnote(cf *CoverageFootnote) string {
	// Sort coverers before formatting
	sortCoverers(cf.Coverers)

	var refs []string
	for _, coverer := range cf.Coverers {
		refs = append(refs, fmt.Sprintf("[%s](%s)", coverer.CoverageLabel, coverer.CoverageUrL))
	}
	hint := fmt.Sprintf("`[~%s/%s~impl]`", cf.PackageID, cf.RequirementName)
	if len(refs) > 0 {
		coverersStr := strings.Join(refs, ", ")
		res := fmt.Sprintf("[^cf%d]: %s %s", cf.ID, hint, coverersStr)
		return res
	}
	return fmt.Sprintf("[^cf%d]: %s", cf.ID, hint)
}

// Build a string representation of the RequirementSite according to the requirements
// CoverageStatusEmoji is ✅ for "covered", and ❓ for "uncvrd"
func FormatRequirementSite(requirementName string, coverageStatusWord CoverageStatusWord, footnoteid CoverageFootnoteId) string {
	result := fmt.Sprintf("`~%s~`", requirementName)

	if coverageStatusWord != "" {
		emoji := CoverageStatusEmojiUncvrd
		if coverageStatusWord == CoverageStatusWordCovered {
			emoji = CoverageStatusEmojiCovered
		}

		result = fmt.Sprintf("%s%s[^cf%d]%s", result, coverageStatusWord, footnoteid, emoji)
	}

	return result
}
````


Made changes.

Now I need to modify the analyzer to handle the new footnote ID system. The analyzer needs to track the maximum footnote ID used in each file and generate new unique IDs when creating footnotes.
````
type analyzer struct {
	coverages        map[RequirementID]*requirementCoverage // RequirementID -> RequirementCoverage
	changedFootnotes map[RequirementID]bool
	maxFootnoteIds   map[FilePath]CoverageFootnoteId // Track max footnote ID per file
}

func NewAnalyzer() IAnalyzer {
	return &analyzer{
		coverages:        make(map[RequirementID]*requirementCoverage),
		changedFootnotes: make(map[RequirementID]bool),
		maxFootnoteIds:   make(map[FilePath]CoverageFootnoteId),
	}
}

// Finds the next available footnote ID for a given file
func (a *analyzer) nextFootnoteId(filePath FilePath) CoverageFootnoteId {
	currentMax, ok := a.maxFootnoteIds[filePath]
	if !ok {
		currentMax = 0
	}
	nextId := currentMax + 1
	a.maxFootnoteIds[filePath] = nextId
	return nextId
}
````


Made changes.

I'll now update the buildRequirementCoverages function to track existing footnote IDs when scanning files, and update analyzeMdActions to use the new ID system.
````
func (a *analyzer) buildRequirementCoverages(files []FileStructure, errors *[]ProcessingError) error {
	// First collect all requirements and their locations
	for _, file := range files {
		if file.Type == FileTypeMarkdown {
			if len(file.Requirements) > 0 && file.PackageID == "" {
				*errors = append(*errors, NewErrMissingPackageIDWithReqs(file.Path, file.Requirements[0].Line))
				continue
			}

			// Track max footnote ID in this file
			for _, cf := range file.CoverageFootnotes {
				if cf.ID > a.maxFootnoteIds[file.Path] {
					a.maxFootnoteIds[file.Path] = cf.ID
				}
			}

			for _, req := range file.Requirements {
				reqID := file.PackageID + "/" + req.RequirementName

				// Check for duplicates using coverages map
				if existing, exists := a.coverages[reqID]; exists {
					*errors = append(*errors, NewErrDuplicateRequirementID(
						existing.FileStructure.Path, existing.Site.Line,
						file.Path, req.Line,
						reqID))
					continue
				}

				// Initialize RequirementCoverage
				coverage := &requirementCoverage{
					Site:          &req,
					FileStructure: &file,
				}
				a.coverages[reqID] = coverage

				// Process existing coverage footnotes
				for _, footnote := range file.CoverageFootnotes {
					if footnote.RequirementName == req.RequirementName {
						// Convert []Coverer to []*Coverer
						coverage.CurrentCoverers = make([]*Coverer, len(footnote.Coverers))
						for i := range footnote.Coverers {
							cov := footnote.Coverers[i]
							coverage.CurrentCoverers[i] = &cov
						}
						break
					}
				}
			}
		}
	}

	// Then collect all coverage tags
	for _, file := range files {
		if file.Type == FileTypeSource {
			for _, tag := range file.CoverageTags {
				if coverage, exists := a.coverages[tag.RequirementID]; exists {
					coverer := &Coverer{
						CoverageLabel: file.RelativePath + ":" + fmt.Sprint(tag.Line) + ":" + tag.CoverageType,
						CoverageUrL:   file.FileURL() + "#L" + strconv.Itoa(tag.Line),
						FileHash:      file.FileHash,
					}
					coverage.NewCoverers = append(coverage.NewCoverers, coverer)
				}
			}
		}
	}

	return nil
}
````


Made changes.

I'll now update the analyzeMdActions function to generate the appropriate footnote IDs and use them in both site updates and footnotes.
````
func (a *analyzer) analyzeMdActions(result *AnalyzerResult) {
	for requirementID, coverage := range a.coverages {
		var footnoteid CoverageFootnoteId

		// Find or create a footnote ID for this requirement
		for _, cf := range coverage.FileStructure.CoverageFootnotes {
			if cf.RequirementName == coverage.Site.RequirementName {
				footnoteid = cf.ID
				break
			}
		}
		if footnoteid == 0 {
			footnoteid = a.nextFootnoteId(coverage.FileStructure.Path)
		}

		// Site action is needed if there's no annotation or coverage status changed
		if !coverage.Site.HasAnnotationRef || statusNeedsUpdate(coverage) {
			newStatus := getCoverageStatus(coverage)
			siteAction := MdAction{
				Type:            ActionSite,
				Path:            coverage.FileStructure.Path,
				Line:            coverage.Site.Line,
				RequirementName: requirementID,
				Data:           FormatRequirementSite(coverage.Site.RequirementName, newStatus, footnoteid),
			}
			result.MdActions[coverage.FileStructure.Path] = append(
				result.MdActions[coverage.FileStructure.Path],
				siteAction,
			)
		}

		// Footnote action is needed if coverers are different or site is not annotated
		if !areCoverersEqualByHashes(coverage.CurrentCoverers, coverage.NewCoverers) || coverage.CurrentCoverers == nil {
			a.changedFootnotes[requirementID] = true

			// Create footnote action
			newCf := &CoverageFootnote{
				PackageID:       coverage.FileStructure.PackageID,
				RequirementName: coverage.Site.RequirementName,
				ID:             footnoteid,
				Coverers:       make([]Coverer, len(coverage.NewCoverers)),
			}
			for i, c := range coverage.NewCoverers {
				newCf.Coverers[i] = *c
			}

			footnoteAction := MdAction{
				Type:            ActionFootnote,
				Path:            coverage.FileStructure.Path,
				RequirementName: coverage.Site.RequirementName,
				Data:           FormatCoverageFootnote(newCf),
			}

			// Find annotation line, keep 0 if not found
			for _, cf := range coverage.FileStructure.CoverageFootnotes {
				if cf.RequirementName == coverage.Site.RequirementName {
					footnoteAction.Line = cf.Line
					break
				}
			}

			// Add actions to result
			result.MdActions[coverage.FileStructure.Path] = append(
				result.MdActions[coverage.FileStructure.Path],
				footnoteAction,
			)
		}
	}
}

// Helper function to determine if coverage status needs to be updated
func statusNeedsUpdate(coverage *requirementCoverage) bool {
	hasCoverers := len(coverage.NewCoverers) > 0
	isCovered := coverage.Site.CoverageStatusWord == CoverageStatusWordCovered

	return (hasCoverers && !isCovered) || (!hasCoverers && isCovered)
}

// Helper function to get appropriate coverage status based on coverers
func getCoverageStatus(coverage *requirementCoverage) CoverageStatusWord {
	if len(coverage.NewCoverers) > 0 {
		return CoverageStatusWordCovered
	}
	return CoverageStatusWordUncvrd
}
````


Made changes.

I'll now update the mdparser.go file to handle the new numeric footnote ID format when parsing markdown files.
````
func ParseCoverageFootnote(mctx *MarkdownContext, filePath string, line string, lineNum int, errs *[]ProcessingError) (footnote *CoverageFootnote) {
	matches := CoverageFootnoteRegex.FindStringSubmatch(line)
	if len(matches) > 0 {
		id, err := strconv.Atoi(matches[1])
		if err != nil {
			// This shouldn't happen since regex ensures digits
			return nil
		}

		footnote = &CoverageFootnote{
			FilePath:        filePath,
			RequirementName: matches[2],
			PackageID:       matches[3],
			ID:             id,
			Line:           lineNum,
		}

		// Parse coverers if present
		if len(matches) > 5 && matches[5] != "" {
			covererMatches := CovererRegex.FindAllStringSubmatch(matches[5], -1)
			for _, covMatch := range covererMatches {
				if len(covMatch) > 2 {
					parsedURL, err := url.Parse(covMatch[2])

					// Add NewErrURLSyntax to errs
					if err != nil {
						*errs = append(*errs, NewErrURLSyntax(filePath, lineNum, covMatch[2]))
						continue
					}

					coverer := Coverer{
						CoverageLabel: covMatch[1],
						CoverageUrL:   covMatch[2],
					}
					fileURL := parsedURL.Scheme + "://" + parsedURL.Host + parsedURL.Path
					if mctx != nil && mctx.rfiles != nil {
						coverer.FileHash = mctx.rfiles.FileURL2FileHash[fileURL]
					}
					footnote.Coverers = append(footnote.Coverers, coverer)
				}
			}
		}
	}
	return footnote
}
````


Made changes.

Let me update ParseRequirements to handle the new footnote reference format and update any relevant tests.
````
func ParseRequirements(filePath string, line string, lineNum int, errors *[]ProcessingError) []RequirementSite {
	var requirements []RequirementSite

	matches := RequirementSiteRegex.FindAllStringSubmatch(line, -1)
	if len(matches) > 1 {
		*errors = append(*errors, NewErrMultiSites(filePath, lineNum, matches[0][0], matches[1][0]))
		return nil
	}

	for _, match := range matches {
		reqName := match[1]
		if !identifierRegex.MatchString(reqName) {
			*errors = append(*errors, NewErrReqIdent(filePath, lineNum))
		}

		covStatus := match[2]
		if covStatus != "" && covStatus != "covered" && covStatus != "uncvrd" {
			*errors = append(*errors, NewErrCoverageStatusWord(filePath, lineNum, covStatus))
			return requirements
		}

		req := RequirementSite{
			FilePath:            filePath,
			RequirementName:     match[1],
			CoverageStatusWord:  CoverageStatusWord(match[2]),
			ReferenceName:       match[3],
			CoverageStatusEmoji: CoverageStatusEmoji(match[4]),
			Line:                lineNum,
			HasAnnotationRef:    match[3] != "",
		}

		if req.HasAnnotationRef && covStatus == "" {
			*errors = append(*errors, NewErrCoverageStatusWord(filePath, lineNum, covStatus))
			return requirements
		}

		requirements = append(requirements, req)
	}

	return requirements
}
````


Made changes.

Let me update the tests to match the new cf-style numeric footnote format. I'll start with models_test.go since it contains tests for formatting functions.
````
func TestFormatCoverageFootnote(t *testing.T) {
	tests := []struct {
		name     string
		footnote *CoverageFootnote
		want     string
	}{
		{
			name: "no coverers",
			footnote: &CoverageFootnote{
				PackageID:       "pkg1",
				RequirementName: "REQ001",
				ID:             1,
			},
			want: "[^cf1]: `[~pkg1/REQ001~impl]`",
		},
		{
			name: "with sorted coverers",
			footnote: &CoverageFootnote{
				RequirementName: "REQ001",
				PackageID:       "pkg2",
				ID:             2,
				Coverers: []Coverer{
					{CoverageLabel: "b.go:1:test", CoverageUrL: "url2"},
					{CoverageLabel: "a.go:1:impl", CoverageUrL: "url1"},
				},
			},
			want: "[^cf2]: `[~pkg2/REQ001~impl]` [a.go:1:impl](url1), [b.go:1:test](url2)",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := FormatCoverageFootnote(tt.footnote)
			assert.Equal(t, tt.want, got)
		})
	}
}
````


Made changes.

I'll now update mdparser_test.go to match the new cf-style numeric footnote format.
````
func Test_ParseCoverageFootnote(t *testing.T) {
	line := "[^cf1]: `[~com.example.basic/REQ002~impl]`[folder1/filename1:line1:impl](https://example.com/pkg1/filename1#L11), [folder2/filename2:line2:test](https://example.com/pkg2/filename2#L22)"
	ctx := &MarkdownContext{
		rfiles: &Reqmdjson{
			FileURL2FileHash: map[string]string{
				"https://example.com/pkg1/filename1": "hash1",
				"https://example.com/pkg2/filename2": "hash2",
			},
		},
	}
	note := ParseCoverageFootnote(ctx, "", line, 1, nil)
	require.NotNil(t, note)

	assert.Equal(t, "REQ002", note.RequirementName, "incorrect requirement ID in footnote")
	assert.Equal(t, "com.example.basic", note.PackageID, "incorrect package ID in footnote")
	assert.Equal(t, 1, note.ID, "incorrect footnote ID")

	require.Len(t, note.Coverers, 2, "should have 2 coverage references")
	assert.Equal(t, "folder1/filename1:line1:impl", note.Coverers[0].CoverageLabel)
	assert.Equal(t, "https://example.com/pkg1/filename1#L11", note.Coverers[0].CoverageUrL)
	assert.Equal(t, "hash1", note.Coverers[0].FileHash)
	assert.Equal(t, "folder2/filename2:line2:test", note.Coverers[1].CoverageLabel)
	assert.Equal(t, "https://example.com/pkg2/filename2#L22", note.Coverers[1].CoverageUrL)
	assert.Equal(t, "hash2", note.Coverers[1].FileHash)
}

func Test_ParseCoverageFootnote2(t *testing.T) {
	line := "[^cf2]: `[~server.design.orch/VVMLeader.def~]` [apps/app.go:80:impl](https://example.com/pkg1/filename1#L80)"
	ctx := &MarkdownContext{
		rfiles: &Reqmdjson{
			FileURL2FileHash: map[string]string{
				"https://example.com/pkg1/filename1": "hash1",
			},
		},
	}
	note := ParseCoverageFootnote(ctx, "", line, 1, nil)
	require.NotNil(t, note)

	assert.Equal(t, "VVMLeader.def", note.RequirementName, "incorrect requirement ID in footnote")
	assert.Equal(t, "server.design.orch", note.PackageID, "incorrect package ID in footnote")
	assert.Equal(t, 2, note.ID, "incorrect footnote ID")

	require.Len(t, note.Coverers, 1, "should have 1 coverer")
	assert.Equal(t, "apps/app.go:80:impl", note.Coverers[0].CoverageLabel)
}
````


Made changes.

I'll now update the analyzer_test.go file since it contains tests that verify both the site updates and footnote generation.
````
// Non-annotated requirement with new coverer
func TestAnalyzer_ActionFootnote_Nan_NewCoverer(t *testing.T) {
	analyzer := NewAnalyzer()

	// Create a markdown file with one requirement
	mdFile := createMdStructureA("req.md", "pkg1", 10, "REQ001", CoverageStatusWordUncvrd)
	mdFile.Requirements[0].HasAnnotationRef = false

	// Create a source file with coverage for that requirement
	srcFile := createSourceFileStructure(
		"src/impl.go",
		"https://github.com/org/repo/blob/main/src/impl.go",
		[]CoverageTag{
			createCoverageTag("pkg1/REQ001", "impl1", 20),
		},
	)

	result, err := analyzer.Analyze([]FileStructure{mdFile, srcFile})
	require.NoError(t, err)
	require.Empty(t, result.ProcessingErrors)

	// Should generate both a footnote and status update action
	actions := result.MdActions[mdFile.Path]
	require.Len(t, actions, 2)

	// Verify status update action
	assert.Equal(t, ActionSite, actions[0].Type)
	assert.Equal(t, "REQ001", actions[0].RequirementName)
	assert.Equal(t, 10, actions[0].Line)
	require.Contains(t, actions[0].Data, "`~REQ001~`covered[^cf1]✅", "site should use cf1 ID and include coverage status")

	// Verify footnote action
	assert.Equal(t, ActionFootnote, actions[1].Type)
	assert.Equal(t, "REQ001", actions[1].RequirementName)
	assert.Contains(t, actions[1].Data, "[^cf1]:", "footnote should use cf1 ID")
	assert.Contains(t, actions[1].Data, "`[~pkg1/REQ001~impl]`", "footnote should have correct hint")
	assert.Contains(t, actions[1].Data, "[src/impl.go:20:impl1]", "footnote should have correct coverage")
	assert.Contains(t, actions[1].Data, "(https://github.com/org/repo/blob/main/src/impl.go/src/impl.go#L20)", "footnote should have correct URL")
}

// Helper function to create a simple FileStructure with one annotated requirement that has cw coverage
func createMdStructureA(path, pkgID string, line int, reqName string, cw CoverageStatusWord) FileStructure {
	emoji := CoverageStatusEmojiUncvrd
	if cw == CoverageStatusWordCovered {
		emoji = CoverageStatusEmojiCovered
	}

	fs := FileStructure{
		Path:      path,
		Type:      FileTypeMarkdown,
		PackageID: pkgID,
		Requirements: []RequirementSite{
			{
				FilePath:            path,
				RequirementName:     reqName,
				Line:                line,
				HasAnnotationRef:    true,
				CoverageStatusWord:  cw,
				CoverageStatusEmoji: emoji,
			},
		},
	}

	if cw == CoverageStatusWordCovered {
		fs.CoverageFootnotes = []CoverageFootnote{
			{
				RequirementName: reqName,
				Line:           line + 10,
				ID:            1,
				Coverers: []Coverer{
					{
						CoverageLabel: "somefolder/somefile.go:15:impl",
						CoverageUrL:   "someurl",
						FileHash:      "somehash",
					},
				},
			},
		}
	}

	return fs
}
````


Made changes.

I'll continue by updating the remaining relevant test in analyzer_test.go to handle the new cf-style IDs.
````
// Annotated uncovered requirement with new coverer
func TestAnalyzer_ActionStatusUpdate_AnUncov_NewCoverer(t *testing.T) {
	analyzer := NewAnalyzer()

	mdFile := createMdStructureA("req.md", "pkg1", 10, "REQ002", CoverageStatusWordUncvrd)

	// Create source files with coverage
	srcFile := createSourceFileStructure(
		"src/impl.go",
		"https://github.com/org/repo/blob/main/src/impl.go",
		[]CoverageTag{
			createCoverageTag("pkg1/REQ002", "impl", 20),
		},
	)

	result, err := analyzer.Analyze([]FileStructure{mdFile, srcFile})
	require.NoError(t, err)
	require.Empty(t, result.ProcessingErrors)

	// Should generate both status update and footnote actions
	actions := result.MdActions[mdFile.Path]
	require.Len(t, actions, 2)

	// Verify site action
	assert.Equal(t, ActionSite, actions[0].Type)
	assert.Equal(t, "REQ002", actions[0].RequirementName)
	assert.Equal(t, 10, actions[0].Line)
	require.Contains(t, actions[0].Data, "`~REQ002~`covered[^cf1]✅", "site should use cf1 ID and correct status")

	// Verify footnote action
	assert.Equal(t, ActionFootnote, actions[1].Type)
	assert.Equal(t, "REQ002", actions[1].RequirementName)
	assert.Contains(t, actions[1].Data, "[^cf1]:", "footnote should use cf1 ID")
	assert.Contains(t, actions[1].Data, "src/impl.go:20:impl", "footnote should have correct coverage")
	assert.Contains(t, actions[1].Data, "https://github.com/org/repo/blob/main/src/impl.go#L20", "footnote should have correct URL")
}

// Annotated covered requirement without coverers
func TestAnalyzer_ActionStatusUpdate_AnCov_NoCoverers(t *testing.T) {
	analyzer := NewAnalyzer()

	// Create a markdown file with covered requirement but no actual coverage
	mdFile := createMdStructureA("req.md", "pkg1", 11, "REQ001", CoverageStatusWordCovered)

	result, err := analyzer.Analyze([]FileStructure{mdFile})
	require.NoError(t, err)
	require.Empty(t, result.ProcessingErrors)

	// Should generate status update action to uncovered
	actions := result.MdActions[mdFile.Path]
	require.Len(t, actions, 2)

	// Verify site action
	assert.Equal(t, ActionSite, actions[0].Type)
	assert.Equal(t, "REQ001", actions[0].RequirementName)
	assert.Equal(t, 11, actions[0].Line)
	require.Contains(t, actions[0].Data, "`~REQ001~`uncvrd[^cf1]❓", "site should use cf1 ID and uncovered status")

	// Verify footnote action
	assert.Equal(t, ActionFootnote, actions[1].Type)
	assert.Equal(t, "REQ001", actions[1].RequirementName)
	assert.Contains(t, actions[1].Data, "[^cf1]:", "footnote should use cf1 ID")
	assert.Contains(t, actions[1].Data, "`[~pkg1/REQ001~impl]`", "footnote should have correct hint")
}

func TestAnalyzer_ActionFootnote_AnCov_NewHash(t *testing.T) {
	analyzer := NewAnalyzer()

	OldCoverageURL := "https://github.com/org/repo/blob/979d75b2c7da961f94396ce2b286e7389eb73d75/old/file.go"
	OldFileHash := "oldhash"
	NewCoverageURL := "https://github.com/org/repo/blob/979d75b2c7da961f94396ce2b286e7389eb73d75/new/file.go"
	NewFileHash := "newhash"

	// Create a markdown file with a requirement and existing footnote
	mdFile := createMdStructureA("req.md", "pkg1", 10, "REQ001", CoverageStatusWordCovered)
	mdFile.CoverageFootnotes = []CoverageFootnote{
		{
			RequirementName: "REQ001",
			Line:            20,
			ID:             1,
			Coverers: []Coverer{
				{
					CoverageLabel: "old/file.go:15:impl",
					CoverageUrL:   OldCoverageURL,
					FileHash:      OldFileHash,
				},
			},
		},
	}

	// Source file with the same Url but new hash
	srcFile := createSourceFileStructure(
		"src/impl.go",
		NewCoverageURL,
		[]CoverageTag{
			createCoverageTag("pkg1/REQ001", "impl", 20),
		},
	)
	srcFile.FileHash = NewFileHash

	result, err := analyzer.Analyze([]FileStructure{mdFile, srcFile})
	require.NoError(t, err)
	require.Empty(t, result.ProcessingErrors)

	actions := result.MdActions[mdFile.Path]
	require.Len(t, actions, 1)

	// Verify footnote update action uses existing line number
	assert.Equal(t, ActionFootnote, actions[0].Type)
	assert.Equal(t, 20, actions[0].Line)
	assert.Contains(t, actions[0].Data, "[^cf1]:", "footnote should use cf1 ID")
	assert.NotContains(t, actions[0].Data, OldCoverageURL)
	assert.Contains(t, actions[0].Data, NewCoverageURL)
}

func TestAnalyzer_ActionFootnote_AnCov_SameHash(t *testing.T) {
	analyzer := NewAnalyzer()

	OldCoverageURL := "https://github.com/org/repo/blob/979d75b2c7da961f94396ce2b286e7389eb73d75/old/file.go"
	OldFileHash := "oldhash"
	NewCoverageURL := "https://github.com/org/repo/blob/979d75b2c7da961f94396ce2b286e7389eb73d75/new/file.go"
	NewFileHash := OldFileHash

	// Create a markdown file with a requirement and existing footnote
	mdFile := createMdStructureA("req.md", "pkg1", 10, "REQ001", CoverageStatusWordCovered)
	mdFile.CoverageFootnotes = []CoverageFootnote{
		{
			RequirementName: "REQ001",
			Line:            20,
			ID:             1,
			Coverers: []Coverer{
				{
					CoverageLabel: "old/file.go:15:impl",
					CoverageUrL:   OldCoverageURL,
					FileHash:      OldFileHash,
				},
			},
		},
	}

	// Source file with the same URL but same hash
	srcFile := createSourceFileStructure(
		"src/impl.go",
		NewCoverageURL,
		[]CoverageTag{
			createCoverageTag("pkg1/REQ001", "impl", 20),
		},
	)
	srcFile.FileHash = NewFileHash

	result, err := analyzer.Analyze([]FileStructure{mdFile, srcFile})
	require.NoError(t, err)
	require.Empty(t, result.ProcessingErrors)

	actions := result.MdActions[mdFile.Path]
	require.Len(t, actions, 0)
}
````


Made changes.

I'll now validate that the changes work as expected by checking for any test failures.

Continue to iterate?
Copilot has been working on this problem for a while. It can continue to iterate, or you can send a new message to refine your prompt.

---

I see there are a couple of errors from my changes that need to be fixed:

1. In models.go, RequirementSiteRegex is redeclared - this is because I defined a new regex pattern but didn't remove the old one.

2. In analyzer_test.go, there's a call to FormatRequirementSite that doesn't provide the new required footnoteid parameter.

Let me fix these issues.
````
package internal

import (
	"encoding/json"
	"fmt"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"
)

// ...existing code...

// CoverageFootnoteId represents a unique identifier for a coverage footnote within a file
type CoverageFootnoteId = int

// CoverageFootnote represents the footnote in Markdown that references coverage tags.
type CoverageFootnote struct {
	FilePath        string
	Line            int
	ID              CoverageFootnoteId // Unique within a file
	PackageID       string
	RequirementName RequirementName
	Coverers        []Coverer
}

var (
	// Example: "[^cf1]: `[~com.example.basic/REQ002~impl]`[folder1/filename1:line1:impl](https://example.com/pkg1/filename1#L10)"
	CoverageFootnoteRegex = regexp.MustCompile(`^\s*\[\^cf(\d+)\]:\s*` + //Footnote reference with numeric ID
		"`\\[~([^~/]+)/([^~]+)~([^\\]]+)?\\]`" + // Hint with package and coverage type
		`(?:\s*(.+))?\s*$`) // Optional coverer list

	// `~REQ001~`uncvrd[^cf1]❓
	RequirementSiteRegex = regexp.MustCompile(
		"`~([^~]+)~`" + // RequirementSiteLabel = "`" "~" RequirementName "~" "`"
		"(?:" + // Optional group for coverage status and footnote
		"\\s*([a-zA-Z]+)?" + // Optional CoverageStatusWord
		"\\s*\\[\\^cf(\\d+)\\]" + // CoverageFootnoteReference with numeric ID
		"\\s*(✅|❓)?" + // Optional CoverageStatusEmoji
		")?")

	CovererRegex = regexp.MustCompile(`\[([^\]]+)\]\(([^)]+)\)`)
)
````


Made changes.

Now let me fix the test file to provide the required footnoteid parameter.
````
// Non-annotated requirement
func TestAnalyzer_ActionFootnote_Nan(t *testing.T) {
	analyzer := NewAnalyzer()

	// Create a markdown file with one requirement
	mdFile := createMdStructureA("req.md", "pkg1", 10, "REQ001", CoverageStatusWordUncvrd)
	mdFile.Requirements[0].HasAnnotationRef = false

	result, err := analyzer.Analyze([]FileStructure{mdFile})
	require.NoError(t, err)
	require.Empty(t, result.ProcessingErrors)

	// Should generate both a footnote and status update action
	actions := result.MdActions[mdFile.Path]
	require.Len(t, actions, 2)

	// Verify status update action
	assert.Equal(t, ActionSite, actions[0].Type)
	assert.Equal(t, "REQ001", actions[0].RequirementName)
	assert.Equal(t, 10, actions[0].Line)
	assert.Equal(t, FormatRequirementSite("REQ001", CoverageStatusWordUncvrd, 1), actions[0].Data)

	// Verify footnote action
	assert.Equal(t, ActionFootnote, actions[1].Type)
	assert.Equal(t, "REQ001", actions[1].RequirementName)
	assert.Contains(t, actions[1].Data, "[^cf1]", "footnote should use cf1 notation")
}
````


Made changes.

Let me verify the changes fixed the errors.I see that while the analyzer_test.go error is fixed, we still have the duplicate RequirementSiteRegex declaration in models.go. Let me search for all occurrences of this variable to make sure I handle the declaration properly.Hmm, the grep_search didn't find any matches which seems incorrect. Let me try semantic_search instead.From the search results, I can see that the RequirementSiteRegex is defined twice in models.go. We need to remove the first declaration since the second one has been updated with the cf-style ID format. Let me fix that.
````
package internal

import (
	"encoding/json"
	"fmt"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"
)

// ...existing code...

// CoverageFootnoteId represents a unique identifier for a coverage footnote within a file
type CoverageFootnoteId = int

// CoverageFootnote represents the footnote in Markdown that references coverage tags.
type CoverageFootnote struct {
	FilePath        string
	Line            int
	ID              CoverageFootnoteId // Unique within a file
	PackageID       string
	RequirementName RequirementName
	Coverers        []Coverer
}

var (
	// Example: "[^cf1]: `[~com.example.basic/REQ002~impl]`[folder1/filename1:line1:impl](https://example.com/pkg1/filename1#L10)"
	CoverageFootnoteRegex = regexp.MustCompile(`^\s*\[\^cf(\d+)\]:\s*` + //Footnote reference with numeric ID
		"`\\[~([^~/]+)/([^~]+)~([^\\]]+)?\\]`" + // Hint with package and coverage type
		`(?:\s*(.+))?\s*$`) // Optional coverer list

	CovererRegex = regexp.MustCompile(`\[([^\]]+)\]\(([^)]+)\)`)
)

// Sort Coverers according to requirements:
// - Coverers shall be sorted by CoverageType, then by FilePath, then by Number, then by CoverageURL
// ...rest of file...
````


Made changes.

Let me verify the change fixed the redeclaration error.The redeclaration error is now fixed. Let me check if there are any other issues with the implementation, particularly around how the new cf-style IDs are parsed and handled.