# High-volume file processing

## Motivation

A comprehensive system test is needed to validate performance and stability under high-load conditions (thousands of files in order).

## Background

```go

type RequirementId struct {
	PackageId       PackageId
	RequirementName RequirementName
}

type FileStructure struct {
	Path              string
	Type              FileType           // indicates if it's Markdown or source
	PackageId         PackageId          // parsed from Markdown header (if markdown)
	Requirements      []RequirementSite  // for Markdown: discovered requirements (bare or annotated)
	CoverageFootnotes []CoverageFootnote // for Markdown: discovered coverage footnotes
	CoverageTags      []CoverageTag      // for source: discovered coverage tags
	FileHash          string             // git hash of the file
	RepoRootFolderURL string
	RelativePath      string
}

type RequirementSite struct {
	Line                int                // line number where the requirement is defined/referenced
	RequirementName     RequirementName    // e.g., "Post.handler"
	CoverageFootnoteId  CoverageFootnoteId // Other.handler for "`~Post.handler~`cov[^~Other.handler~]"
	CoverageStatusWord  CoverageStatusWord // "covered", "uncvrd", or empty
	CoverageStatusEmoji CoverageStatusEmoji
	HasAnnotationRef    bool // true if it already has coverage annotation reference, false if itâ€™s bare
}

type CoverageFootnote struct {
	Line               int
	PackageId          PackageId
	RequirementName    RequirementName
	CoverageFootnoteId CoverageFootnoteId
	Coverers           []Coverer
}

type CoverageTag struct {
	RequirementId RequirementId // e.g., "server.api.v2/Post.handler"
	CoverageType  string        // e.g., "impl", "test"
	Line          int           // line number where the coverage tag was found
}
```

---

## Test architecture

### Config

- NumReqSites: 1000
- AvgSitesPerPackage: 1-10
- AvgTagsPerSite: 0-5
- AvgSitesPerFile: 0-5
  - Must be less than AvgSitesPerPackage
  - AvgTagPerFile: 0-6
- MaxTreeDepth: 4

### hvgen.HVGenerator()

Generates test files with configurable parameters

- Input: cfg Config
- Generate `folderNames` []string{"f1", "f2", "f3", "f4"...}
  - Len is MaxTreeDepth  
- Generate `reqIds` []RequirementId
  - Input: cfg.NumReqSites, cfg.AvgSitesPerPackage
  - Sorted by PackageId
- Generate `reqIdPerFile` [][]RequirementId
  - Input: `reqIds`, AvgSitesPerFile
  - Each element contains RequirementId with the same PackageId
- Generate `ctags` []CoverageTags, `reqToTags map[RequirementId][]CoverageTags`
  - Input: AvgTagsPerSite, `reqIds`
  - Output: []CoverageTag
    - RequirementId: randomly selected from `reqIds`
    - CoverageType: randomly selected from "impl", "test".
- Generate `ctagPerFile` [][]CoverageTags
  - Input: `ctags`, cfg.AvgTagsPerFile  
- Generate `fileStructs` []FileStructure, core fields
  - Input: `reqIdPerFile`, `ctagPerFile`, `folderNames`
  - for `reqTagIdx` range max(len(reqIdPerFile), len(ctagPerFile))
    - Construct fs FileStructure
      - fs.Path: Constructed from a random number [0; len(folderNames)-1] of random elements from `folderNames`
      - fs.Type: Markdown or source, randomly selected, 1:5
      - fs.PackageId
        - if ReqIdPerFile[`reqTagIdx`] exists then ReqIdPerFile[`reqTagIdx`][0].PackageId
      - fs.Requirements
        - if ReqIdPerFile[`reqTagIdx`] exists then construct using ReqIdPerFile[`reqTagIdx`] (index in `idx`)
          - Line: randomly selected from 1 to 100, avoid duplicates
          - RequirementName: ReqIdPerFile[idx]RequirementName
          - CoverageFootnoteId: Monotonically increasing number, per fs, starting from 1
      - fs.CoverageTags
        - if ctagPerFile[`reqTagIdx`] exists then construct using ctagPerFile[`reqTagIdx`] (index in `idx`)
          - Line: randomly selected from 1 to 100, avoid duplicates
          - RequirementId: ctagPerFile[idx].RequirementId
          - CoverageType: ctagPerFile[idx].CoverageType

Flow overview:

- `reqIds map[RequirementId]struct{}`
